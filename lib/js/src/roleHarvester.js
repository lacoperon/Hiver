// Generated by BUCKLESCRIPT VERSION 1.8.1, PLEASE EDIT WITH CARE
'use strict';

var Block           = require("bs-platform/lib/js/block.js");
var Curry           = require("bs-platform/lib/js/curry.js");
var Random          = require("bs-platform/lib/js/random.js");
var Caml_array      = require("bs-platform/lib/js/caml_array.js");
var RoomObject      = require("./roomObject.js");
var ConstantConv    = require("./constantConv.js");
var Supplemental    = require("./supplemental");
var HelperFunctions = require("./helperFunctions.js");

function runCreep(creep) {
  var carryCap = creep.carryCapacity;
  var load = creep.carry.energy;
  var currentRoom = creep.room;
  if (!Supplemental.isAssignedSource(creep)) {
    var energySources = RoomObject.find(currentRoom, /* FIND_SOURCES_ACTIVE */8);
    var i = Random.$$int(energySources.length);
    var chosenSourceID = Caml_array.caml_array_get(energySources, i).id;
    HelperFunctions.setMemoryField(creep, /* Memory_Source */Block.__(4, [chosenSourceID]));
  }
  if (load < carryCap) {
    var sourceID = creep.memory.source;
    var chosenSource = Supplemental.getObjectFromID(sourceID);
    if (creep.harvest(chosenSource) === ConstantConv.toNumResult(/* ERR_NOT_IN_RANGE */9)) {
      creep.moveTo(chosenSource);
      return /* () */0;
    } else {
      return 0;
    }
  } else {
    var structureArray = RoomObject.find(currentRoom, /* FIND_STRUCTURES */12);
    var isSpawnOrExtension = function (ro) {
      var match = RoomObject.get_struct_type(ro);
      if (match >= 2) {
        return /* false */0;
      } else {
        return /* true */1;
      }
    };
    var spawnsAndExtensions = Curry._2(HelperFunctions.$$Array[/* filter */20], isSpawnOrExtension, structureArray);
    var chosenStructure = Caml_array.caml_array_get(spawnsAndExtensions, 0);
    creep.transfer(chosenStructure, "energy");
    creep.moveTo(chosenStructure);
    return /* () */0;
  }
}

exports.runCreep = runCreep;
/* ./supplemental Not a pure module */
