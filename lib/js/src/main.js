// Generated by BUCKLESCRIPT VERSION 1.8.1, PLEASE EDIT WITH CARE
'use strict';

var $$Array         = require("bs-platform/lib/js/array.js");
var Block           = require("bs-platform/lib/js/block.js");
var Spawn           = require("./spawn.js");
var Caml_array      = require("bs-platform/lib/js/caml_array.js");
var RoomObject      = require("./roomObject.js");
var ConstantConv    = require("./constantConv.js");
var Supplement      = require("./supplemental");
var HelperFunctions = require("./helperFunctions.js");

var creeps = (Object.keys(Game.creeps));

var spawns = (Object.keys(Game.spawns));

function iterateCreeps() {
  var x = creeps.length;
  if (x !== 0) {
    for(var i = 0 ,i_finish = x - 1 | 0; i <= i_finish; ++i){
      var creepName = Caml_array.caml_array_get(creeps, i);
      var creep = Supplement.getCreep(creepName);
      var carryCap = creep.carryCapacity;
      var load = creep.carry.energy;
      var currentRoom = creep.room;
      var energySources = RoomObject.find(currentRoom, /* FIND_SOURCES */9);
      var chosenSource = Caml_array.caml_array_get(energySources, 0);
      if (load < carryCap) {
        if (creep.harvest(chosenSource) === ConstantConv.toNumResult(/* ERR_NOT_IN_RANGE */9)) {
          creep.moveTo(chosenSource);
        }
        
      } else {
        var structureArray = RoomObject.find(currentRoom, /* FIND_STRUCTURES */12);
        var isSpawnOrExtension = function (ro) {
          var match = RoomObject.get_struct_type(ro);
          if (match >= 2) {
            return /* false */0;
          } else {
            return /* true */1;
          }
        };
        var spawnsAndExtensions = HelperFunctions.arrayFilter(isSpawnOrExtension, structureArray);
        var chosenStructure = Caml_array.caml_array_get(spawnsAndExtensions, 0);
        creep.transfer(chosenStructure, "energy");
        creep.moveTo(chosenStructure);
      }
    }
    return /* () */0;
  } else {
    console.log("There are no creeps to iterate over");
    return /* () */0;
  }
}

function iterateSpawns() {
  for(var i = 0 ,i_finish = spawns.length - 1 | 0; i <= i_finish; ++i){
    var body = /* int array */[
      /* WORK */1,
      /* CARRY */2,
      /* MOVE */0,
      /* MOVE */0
    ];
    var spawn = Supplement.getSpawn(Caml_array.caml_array_get(spawns, i));
    var room = spawn.room;
    var energyAvailable = room.energyAvailable;
    var bodyCost = HelperFunctions.arraySum($$Array.map(ConstantConv.bodyPartToCost, body));
    if (bodyCost <= energyAvailable) {
      Spawn.spawnCreepWithMemory(Caml_array.caml_array_get(spawns, i), body, /* Memory_Role */Block.__(1, [/* Harvester */0]));
      console.log("Spawning new creep");
    }
    
  }
  return /* () */0;
}

function run() {
  iterateSpawns(/* () */0);
  iterateCreeps(/* () */0);
  Supplement.doWatcher("");
  return /* () */0;
}

var runEachTick = run(/* () */0);

exports.creeps        = creeps;
exports.spawns        = spawns;
exports.iterateCreeps = iterateCreeps;
exports.iterateSpawns = iterateSpawns;
exports.run           = run;
exports.runEachTick   = runEachTick;
/* creeps Not a pure module */
