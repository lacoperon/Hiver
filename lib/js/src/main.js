// Generated by BUCKLESCRIPT VERSION 1.8.1, PLEASE EDIT WITH CARE
'use strict';

var List         = require("bs-platform/lib/js/list.js");
var $$Array      = require("bs-platform/lib/js/array.js");
var Block        = require("bs-platform/lib/js/block.js");
var Caml_array   = require("bs-platform/lib/js/caml_array.js");
var Pervasives   = require("bs-platform/lib/js/pervasives.js");
var ConstantConv = require("./constantConv.js");
var Supplement   = require("./supplemental");

var creeps = (Object.keys(Game.creeps));

var creepsObject = (Game.creeps);

var spawns = (Object.keys(Game.spawns));

var spawnsObject = (Game.spawns);

function arrayFilter(filter, array) {
  var list = $$Array.to_list(array);
  return $$Array.of_list(List.filter(filter)(list));
}

function arraySumRecursive(numArray, _currentSum, _currentIndex) {
  while(true) {
    var currentIndex = _currentIndex;
    var currentSum = _currentSum;
    if (numArray.length === currentIndex) {
      return currentSum;
    } else {
      _currentIndex = currentIndex + 1 | 0;
      _currentSum = currentSum + Caml_array.caml_array_get(numArray, currentIndex) | 0;
      continue ;
      
    }
  };
}

function arraySum(numArray) {
  return arraySumRecursive(numArray, 0, 0);
}

function bodyPartToCost(part) {
  switch (part) {
    case 1 : 
        return 100;
    case 0 : 
    case 2 : 
        return 50;
    case 3 : 
        return 80;
    case 4 : 
        return 150;
    case 5 : 
        return 250;
    case 6 : 
        return 10;
    case 7 : 
        return 600;
    
  }
}

function bodyPartToString(part) {
  switch (part) {
    case 0 : 
        return "move";
    case 1 : 
        return "work";
    case 2 : 
        return "carry";
    case 3 : 
        return "attack";
    case 4 : 
        return "ranged_attack";
    case 5 : 
        return "heal";
    case 6 : 
        return "tough";
    case 7 : 
        return "claim";
    
  }
}

function roleToString() {
  return "harvester";
}

function setMemoryField(creepName, memory) {
  if (typeof memory === "number") {
    return /* () */0;
  } else if (memory.tag) {
    Supplement.defineMemoryHelper(creepName, "role", "harvester");
    return /* () */0;
  } else {
    Supplement.defineMemoryHelper(creepName, "working", memory[0] !== 0 ? "true" : "false");
    return /* () */0;
  }
}

function spawnCreepWithMemory(spawn, body, mfa) {
  var $js;
  $js = typeof mfa === "number" ? /* array */[] : (
      mfa.tag ? /* array */[
          "role",
          "harvester"
        ] : /* array */[
          "working",
          mfa[0] ? "true" : "false"
        ]
    );
  return Supplement.spawnCreepWithMemoryHelper(spawn, $$Array.map(bodyPartToString, body), $js);
}

function get_struct_type(r) {
  return ConstantConv.fromStringStructure(r.structureType);
}

function find(r, f) {
  return r.find(ConstantConv.toNumFilter(f));
}

function iterateCreeps() {
  var x = creeps.length;
  if (x !== 0) {
    console.log("There are " + (Pervasives.string_of_int(x) + " creeps currently"));
    for(var i = 0 ,i_finish = creeps.length - 1 | 0; i <= i_finish; ++i){
      var creepName = Caml_array.caml_array_get(creeps, i);
      var creep = Supplement.getCreep(creepName);
      var carryCap = creep.carryCapacity;
      var load = creep.carry.energy;
      var currentRoom = creep.room;
      var energySources = currentRoom.find(ConstantConv.toNumFilter(/* FIND_SOURCES */9));
      var chosenSource = Caml_array.caml_array_get(energySources, 0);
      if (load < carryCap) {
        if (creep.harvest(chosenSource) === ConstantConv.toNumResult(/* ERR_NOT_IN_RANGE */9)) {
          creep.moveTo(chosenSource);
        }
        
      } else {
        var structureArray = currentRoom.find(ConstantConv.toNumFilter(/* FIND_STRUCTURES */12));
        var isSpawnOrExtension = function (ro) {
          var match = ConstantConv.fromStringStructure(ro.structureType);
          if (match >= 2) {
            return /* false */0;
          } else {
            return /* true */1;
          }
        };
        var spawnsAndExtensions = arrayFilter(isSpawnOrExtension, structureArray);
        var chosenStructure = Caml_array.caml_array_get(spawnsAndExtensions, 0);
        console.log(chosenStructure);
        creep.transfer(chosenStructure, "energy");
        creep.moveTo(chosenStructure);
      }
    }
    return /* () */0;
  } else {
    console.log("There are no creeps to iterate over");
    return /* () */0;
  }
}

function iterateSpawns() {
  for(var i = 0 ,i_finish = spawns.length - 1 | 0; i <= i_finish; ++i){
    var body = /* int array */[
      /* WORK */1,
      /* CARRY */2,
      /* MOVE */0,
      /* MOVE */0
    ];
    spawnCreepWithMemory(Caml_array.caml_array_get(spawns, i), body, /* Memory_Role */Block.__(1, [/* Harvester */0]));
  }
  return /* () */0;
}

function run() {
  iterateSpawns(/* () */0);
  Supplement.doWatcher("");
  return iterateCreeps(/* () */0);
}

var runEachTick = run(/* () */0);

var creepsArray = creeps;

var spawnsArray = spawns;

exports.creeps               = creeps;
exports.creepsArray          = creepsArray;
exports.creepsObject         = creepsObject;
exports.spawns               = spawns;
exports.spawnsArray          = spawnsArray;
exports.spawnsObject         = spawnsObject;
exports.arrayFilter          = arrayFilter;
exports.arraySumRecursive    = arraySumRecursive;
exports.arraySum             = arraySum;
exports.bodyPartToCost       = bodyPartToCost;
exports.bodyPartToString     = bodyPartToString;
exports.roleToString         = roleToString;
exports.setMemoryField       = setMemoryField;
exports.spawnCreepWithMemory = spawnCreepWithMemory;
exports.get_struct_type      = get_struct_type;
exports.find                 = find;
exports.iterateCreeps        = iterateCreeps;
exports.iterateSpawns        = iterateSpawns;
exports.run                  = run;
exports.runEachTick          = runEachTick;
/* creeps Not a pure module */
