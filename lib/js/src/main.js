// Generated by BUCKLESCRIPT VERSION 1.8.1, PLEASE EDIT WITH CARE
'use strict';

var Creep           = require("./creep.js");
var Curry           = require("bs-platform/lib/js/curry.js");
var Spawn           = require("./spawn.js");
var Tower           = require("./tower.js");
var Caml_obj        = require("bs-platform/lib/js/caml_obj.js");
var Caml_array      = require("bs-platform/lib/js/caml_array.js");
var RoomObject      = require("./roomObject.js");
var RoleBuilder     = require("./roleBuilder.js");
var ConstantConv    = require("./constantConv.js");
var RoleUpgrader    = require("./roleUpgrader.js");
var RoleHarvester   = require("./roleHarvester.js");
var Supplement      = require("./supplemental");
var HelperFunctions = require("./helperFunctions.js");

var creeps = (Object.keys(Game.creeps));

var realCreeps = Curry._2(HelperFunctions.$$Array[/* map */12], (function (prim) {
        return Supplement.getCreep(prim);
      }), creeps);

var spawns = (Object.keys(Game.spawns));

function iterateCreeps() {
  var x = creeps.length;
  if (x !== 0) {
    for(var i = 0 ,i_finish = x - 1 | 0; i <= i_finish; ++i){
      var creepName = Caml_array.caml_array_get(creeps, i);
      var creep = Supplement.getCreep(creepName);
      var creepRole = Creep.getRole(creep);
      switch (creepRole) {
        case 0 : 
            RoleHarvester.runCreep(creep);
            break;
        case 1 : 
            RoleUpgrader.runCreep(creep);
            break;
        case 2 : 
            RoleBuilder.runCreep(creep);
            break;
        
      }
    }
    return /* () */0;
  } else {
    console.log("There are no creeps to iterate over");
    return /* () */0;
  }
}

function iterateSpawns() {
  for(var i = 0 ,i_finish = spawns.length - 1 | 0; i <= i_finish; ++i){
    var body = /* int array */[
      /* WORK */1,
      /* CARRY */2,
      /* MOVE */0,
      /* MOVE */0
    ];
    var spawnString = Caml_array.caml_array_get(spawns, i);
    var spawn = Supplement.getSpawn(spawnString);
    var room = spawn.room;
    var structures = RoomObject.find(room, /* FIND_MY_STRUCTURES */13);
    var isTower = function (ro) {
      var match = RoomObject.get_struct_type(ro);
      if (match !== 10) {
        return /* false */0;
      } else {
        return /* true */1;
      }
    };
    var towersArray = Curry._2(HelperFunctions.$$Array[/* filter */20], isTower, structures);
    var numTowers = towersArray.length;
    if (numTowers !== 0) {
      for(var i$1 = 0 ,i_finish$1 = numTowers - 1 | 0; i$1 <= i_finish$1; ++i$1){
        Tower.runTower(Caml_array.caml_array_get(towersArray, i$1));
      }
    }
    var energyAvailable = room.energyAvailable;
    var bodyCost = HelperFunctions.arraySum(Curry._2(HelperFunctions.$$Array[/* map */12], ConstantConv.bodyPartToCost, body));
    var roleToOne = function (r, creep) {
      if (Caml_obj.caml_equal(Creep.getRole(creep), r)) {
        return 1;
      } else {
        return 0;
      }
    };
    if (bodyCost <= energyAvailable) {
      var harvesterIntArray = Curry._2(HelperFunctions.$$Array[/* map */12], (function (param) {
              return roleToOne(/* Harvester */0, param);
            }), realCreeps);
      var harvesterNum = HelperFunctions.arraySum(harvesterIntArray);
      var upgraderIntArray = Curry._2(HelperFunctions.$$Array[/* map */12], (function (param) {
              return roleToOne(/* Upgrader */1, param);
            }), realCreeps);
      var upgraderNum = HelperFunctions.arraySum(upgraderIntArray);
      var builderIntArray = Curry._2(HelperFunctions.$$Array[/* map */12], (function (param) {
              return roleToOne(/* Builder */2, param);
            }), realCreeps);
      var builderNum = HelperFunctions.arraySum(builderIntArray);
      if (harvesterNum < 10) {
        var largestBody = Spawn.createLargestTandemBody(spawn, body);
        Spawn.spawnCreepWithRole(spawnString, largestBody, /* Harvester */0);
        console.log("Spawning new harvester creep");
      }
      if (upgraderNum < 10) {
        var largestBody$1 = Spawn.createLargestTandemBody(spawn, body);
        Spawn.spawnCreepWithRole(spawnString, largestBody$1, /* Upgrader */1);
        console.log("Spawning new upgrader creep");
      }
      if (builderNum < 5) {
        var largestBody$2 = Spawn.createLargestTandemBody(spawn, body);
        Spawn.spawnCreepWithRole(spawnString, largestBody$2, /* Builder */2);
        console.log("Spawning new builder creep");
      }
      
    }
    
  }
  return /* () */0;
}

function run() {
  iterateCreeps(/* () */0);
  iterateSpawns(/* () */0);
  Supplement.doWatcher("");
  Supplement.clearDeadCreepsFromMemory("");
  return /* () */0;
}

var runEachTick = run(/* () */0);

exports.creeps        = creeps;
exports.realCreeps    = realCreeps;
exports.spawns        = spawns;
exports.iterateCreeps = iterateCreeps;
exports.iterateSpawns = iterateSpawns;
exports.run           = run;
exports.runEachTick   = runEachTick;
/* creeps Not a pure module */
